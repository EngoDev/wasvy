package wasvy:ecs;

/// This is the world that the bevy host implements to give ECS functionality to the WASM component.
/// Like `register-system`.
world host {
	import app;
}

/// This is the world that the WASM guest implements.
///
/// These are basically the mandatory functons that a WASM component
/// must have for it to be called from the Bevy host.
world guest {
	import app;
	import system-params;
	import types;

	/// This function is called once on startup for each WASM component (Not Bevy component).
	export setup: func();
}

interface app {
	use types.{schedule, query};

	/// A mod, similar to bevy::App
	resource app {
		/// Construct an new App: an interface through which mods may interact with the bevy world.
		///
		/// Each mod may only do this once inside its setup function call. Attempting to do this
		/// twice or outside setup will trap.
		constructor();

		/// Adds systems to the mod
		add-systems: func(
			schedule: schedule,
			systems: list<system>,
		);
	}

	/// An interface with which to define a new system for the host
	///
	/// Usage:
	/// 1. Construct a new system, giving it a unique name
	/// 2. Add system-params by calling 0 or more add-* methods
	/// 3. Order the system relative to others
	/// 4. Add the system to a schedule
	resource system {
		/// Constructs a new system. Use the same name as exported in
		/// the guest world, otherwise the host won't be able to find it.
		constructor(name: string);

		/// Adds a commands system-param
		add-commands: func();

		/// Adds a query system-param
		add-query: func(query: list<query>);

		/// Schedules this system be run before another system
		before: func(other: borrow<system>);

		/// Schedules this system be run after another system
		after: func(other: borrow<system>);
	}
}

interface system-params {
	use types.{component};

	/// A commands system param
	resource commands {
		spawn: func(components: list<component>);
		// etc
	}

	/// A commands system param
	resource query-results {
		/// Evaluates and returns the next query results
		iter: func() -> option<list<component>>;
	}
}

interface types {
	resource component {
		/// Gets the value of a component
		get: func() -> serialized-component;

		/// Sets the value of a component
		///
		/// Traps if this component was not declared as mutable
		set: func(value: serialized-component);
	}

	/// A fully-qualified type name
	type type-name = string;

	/// JSON serialized version of the actual component that is being passed between WASM and Bevy.
	/// So for every instance of `component` make sure you deserialize it yourself to the struct that it actually is.
	///
	/// Note: for components returned by query::optional this is an option<t>
	type serialized-component = string;

	enum schedule {
		/// Runs during the bevy Update schedule
		update
	}

	variant query {
		ref(type-name),
		mut(type-name),
		optional(type-name),
		%with(type-name),
		without(type-name),
	}
}